// http://mrl.nyu.edu/~perlin/noise/

var ImprovedNoise = function () {

    var p = [151,160,137,91,90,15,131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,
         23,190,6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,88,237,149,56,87,
         174,20,125,136,171,168,68,175,74,165,71,134,139,48,27,166,77,146,158,231,83,111,229,122,60,211,
         133,230,220,105,92,41,55,46,245,40,244,102,143,54,65,25,63,161,1,216,80,73,209,76,132,187,208,
         89,18,169,200,196,135,130,116,188,159,86,164,100,109,198,173,186,3,64,52,217,226,250,124,123,5,
         202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,223,183,170,213,119,
         248,152,2,44,154,163,70,221,153,101,155,167,43,172,9,129,22,39,253,19,98,108,110,79,113,224,232,
         178,185,112,104,218,246,97,228,251,34,242,193,238,210,144,12,191,179,162,241,81,51,145,235,249,
         14,239,107,49,192,214,31,181,199,106,157,184,84,204,176,115,121,50,45,127,4,150,254,138,236,205,
         93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];

    for ( var i = 0; i < 256 ; i++ ) {

        p[ 256 + i ] = p[ i ];

    }

    function fade( t ) {

        return t * t * t * ( t * ( t * 6 - 15 ) + 10 );

    }

    function lerp( t, a, b ) {

        return a + t * ( b - a );

    }

    function grad( hash, x, y, z ) {

        var h = hash & 15;
        var u = h < 8 ? x : y, v = h < 4 ? y : h == 12 || h == 14 ? x : z;
        return ( ( h & 1 ) == 0 ? u : -u ) + ( ( h & 2 ) == 0 ? v : -v );

    }

    return {

        noise: function ( x, y, z ) {

            var floorX = Math.floor( x ), floorY = Math.floor( y ), floorZ = Math.floor( z );

            var X = floorX & 255, Y = floorY & 255, Z = floorZ & 255;

            x -= floorX;
            y -= floorY;
            z -= floorZ;

            var xMinus1 = x -1, yMinus1 = y - 1, zMinus1 = z - 1;

            var u = fade( x ), v = fade( y ), w = fade( z );

            var A = p[ X ] + Y, AA = p[ A ] + Z, AB = p[ A + 1 ] + Z, B = p[ X + 1 ] + Y, BA = p[ B ] + Z, BB = p[ B + 1 ] + Z;

            return lerp( w, lerp( v, lerp( u, grad( p[ AA ], x, y, z ),
                               grad( p[ BA ], xMinus1, y, z ) ),
                          lerp( u, grad( p[ AB ], x, yMinus1, z ),
                               grad( p[ BB ], xMinus1, yMinus1, z ) ) ),
                     lerp( v, lerp( u, grad( p[ AA + 1 ], x, y, zMinus1 ),
                               grad( p[ BA + 1 ], xMinus1, y, z - 1 ) ),
                          lerp( u, grad( p[ AB + 1 ], x, yMinus1, zMinus1 ),
                               grad( p[ BB + 1 ], xMinus1, yMinus1, zMinus1 ) ) ) );

        }
    }
}

var currentRandom = Math.random;

// Pseudo-random generator
function Marsaglia(i1, i2) {
  // from http://www.math.uni-bielefeld.de/~sillke/ALGORITHMS/random/marsaglia-c
  var z=i1 || 362436069, w= i2 || 521288629;
  var nextInt = function() {
    z=(36969*(z&65535)+(z>>>16)) & 0xFFFFFFFF;
    w=(18000*(w&65535)+(w>>>16)) & 0xFFFFFFFF;
    return (((z&0xFFFF)<<16) | (w&0xFFFF)) & 0xFFFFFFFF;
  };
 
  this.nextDouble = function() {
    var i = nextInt() / 4294967296;
    return i < 0 ? 1 + i : i;
  };
  this.nextInt = nextInt;
}
Marsaglia.createRandomized = function() {
  var now = new Date();
  return new Marsaglia((now / 60000) & 0xFFFFFFFF, now & 0xFFFFFFFF);
};      

// Noise functions and helpers
function PerlinNoise(seed) {
  var rnd = seed !== undefined ? new Marsaglia(seed) : Marsaglia.createRandomized();
  var i, j;
  // http://www.noisemachine.com/talk1/17b.html
  // http://mrl.nyu.edu/~perlin/noise/
  // generate permutation
  var p = new Array(512); 
  for(i=0;i<256;++i) { p[i] = i; }
  for(i=0;i<256;++i) { var t = p[j = rnd.nextInt() & 0xFF]; p[j] = p[i]; p[i] = t; }
  // copy to avoid taking mod in p[0];
  for(i=0;i<256;++i) { p[i + 256] = p[i]; } 
  
  function grad3d(i,x,y,z) {        
    var h = i & 15; // convert into 12 gradient directions
    var u = h<8 ? x : y,                 
        v = h<4 ? y : h===12||h===14 ? x : z;
    return ((h&1) === 0 ? u : -u) + ((h&2) === 0 ? v : -v);
  }

  function grad2d(i,x,y) { 
    var v = (i & 1) === 0 ? x : y;
    return (i&2) === 0 ? -v : v;
  }
  
  function grad1d(i,x) { 
    return (i&1) === 0 ? -x : x;
  }
  
  function lerp(t,a,b) { return a + t * (b - a); }
    
  this.noise3d = function(x, y, z) {
    var X = Math.floor(x)&255, Y = Math.floor(y)&255, Z = Math.floor(z)&255;
    x -= Math.floor(x); y -= Math.floor(y); z -= Math.floor(z);
    var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y, fz = (3-2*z)*z*z;
    var p0 = p[X]+Y, p00 = p[p0] + Z, p01 = p[p0 + 1] + Z, p1  = p[X + 1] + Y, p10 = p[p1] + Z, p11 = p[p1 + 1] + Z;
    return lerp(fz, 
      lerp(fy, lerp(fx, grad3d(p[p00], x, y, z), grad3d(p[p10], x-1, y, z)),
               lerp(fx, grad3d(p[p01], x, y-1, z), grad3d(p[p11], x-1, y-1,z))),
      lerp(fy, lerp(fx, grad3d(p[p00 + 1], x, y, z-1), grad3d(p[p10 + 1], x-1, y, z-1)),
               lerp(fx, grad3d(p[p01 + 1], x, y-1, z-1), grad3d(p[p11 + 1], x-1, y-1,z-1))));
  };
  
  this.noise2d = function(x, y) {
    var X = Math.floor(x)&255, Y = Math.floor(y)&255;
    x -= Math.floor(x); y -= Math.floor(y);
    var fx = (3-2*x)*x*x, fy = (3-2*y)*y*y;
    var p0 = p[X]+Y, p1  = p[X + 1] + Y;
    return lerp(fy, 
      lerp(fx, grad2d(p[p0], x, y), grad2d(p[p1], x-1, y)),
      lerp(fx, grad2d(p[p0 + 1], x, y-1), grad2d(p[p1 + 1], x-1, y-1)));
  };

  this.noise1d = function(x) {
    var X = Math.floor(x)&255;
    x -= Math.floor(x);
    var fx = (3-2*x)*x*x;
    return lerp(fx, grad1d(p[X], x), grad1d(p[X+1], x-1));
  };
}

//  these are lifted from Processing.js
// processing defaults
var noiseProfile = { generator: undefined, octaves: 4, fallout: 0.5, seed: undefined};

function noise(x, y, z) {
  if(noiseProfile.generator === undefined) {
    // caching
    noiseProfile.generator = new PerlinNoise(noiseProfile.seed);
  }
  var generator = noiseProfile.generator;
  var effect = 1, k = 1, sum = 0;
  for(var i=0; i<noiseProfile.octaves; ++i) {
    effect *= noiseProfile.fallout;        
    switch (arguments.length) {
    case 1:
      sum += effect * (1 + generator.noise1d(k*x))/2; break;
    case 2:
      sum += effect * (1 + generator.noise2d(k*x, k*y))/2; break;
    case 3:
      sum += effect * (1 + generator.noise3d(k*x, k*y, k*z))/2; break;
    }
    k *= 2;
  }
  return sum;
};
'use strict';

var SongManager = (function () {

  var BEAT_MIN = 0.15; //a volume less than this is no beat
  var beatTime = 0;
  var beatHoldTime = 40;
  var beatDecayRate = 0.97;

  function SongManager(ui) {
    // body...
    var AudioContext = window.AudioContext || window.webkitAudioContext;
    this.context = new AudioContext();
    this.allValues = [];
    this.beatCutOff = 0;
    this.audioNodeSettedUp = false;
    this.UI = ui;

  }

  SongManager.prototype.load = function (fun) {  
    this.audio = window.audio = document.getElementById('player');  

    window.songman = this;

    console.log("loading...", window.audio);



    //window.audio.addEventListener('canplaythrough', function () {
    if (!window.songman.sourceNode) {
      window.songman.setupAudioNodes();
      fun.call();
    }

    //}, false);

  };

  SongManager.prototype.loadAndUpdate = function (trackUrl) {
    var $$ = this;
    this.loader.loadStream(trackUrl,
      function () {
        //uiUpdater.clearInfoPanel();
        //console.log($$.source);
        $$.playStream($$.loader.streamUrl());
        $$.UI.update($$.loader);
        setTimeout($$.UI.toggleControlPanel, 3000); // auto-hide the control panel
      },
      function () {
        //$$.UI.displayMessage("Error", loader.errorMessage);
      });
  };


  SongManager.prototype.render = function () {  
    // update data in frequencyData
         
    //this.analyser.getByteFrequencyData(this.frequencyData);     
    // render frame based on values in frequencyData
    //console.log(this.frequencyData);
  }


  SongManager.prototype.setupAudioNodes = function () {

    this.volume = 0;
    this.streamData = new Uint8Array(128);

    this.analyser = (this.analyser || this.context.createAnalyser());

    // we could configure the analyser: e.g. analyser.fftSize (for further infos read the spec)
    // frequencyBinCount tells you how many values you'll receive from the analyser

    this.analyser.smoothingTimeConstant = 0.8;
    //this.analyser.fftSize = 512;
    this.analyser.fftSize = 1024;
    //songman.analyser.fftSize = 256;

    this.loader = new SoundcloudLoader(this.audio, this.UI);
    //this.audiosource = new SoundCloudAudioSource(this.audio, this);

    console.log(this.loader);

    //setInterval(this.sampleAudioStream, 20);

    //if (!this.sourceNode)
    this.sourceNode = this.context.createMediaElementSource(window.audio);
    this.sourceNode.connect(this.analyser);
    this.sourceNode.connect(this.context.destination);

    this.frequencyData = new Uint8Array(this.analyser.frequencyBinCount);   

    console.log("loaded !");
    this.audioNodeSettedUp = true;
    //window.audio.play();

  }


  SongManager.prototype.playStream = function (streamUrl) {
    var $$ = this;
    // get the input stream from the audio element
    window.audio.addEventListener('ended', function () {
      $$.loader.directStream('coasting');
    });
    window.audio.setAttribute('src', streamUrl);
    window.audio.play();
  }


  SongManager.prototype.sampleAudioStream = function () {
    this.analyser.getByteFrequencyData(this.streamData);
    // calculate an overall volume value
    var total = 0;
    for (var i = 0; i < 80; i++) { // get the volume from the first 80 bins, else it gets too loud with treble
      total += this.streamData[i];
    }
    this.volume = total;
  };


  SongManager.prototype.getSoundDataAverage = function (array) {
    this.analyser.smoothingTimeConstant = 0.1;
    this.analyser.getByteFrequencyData(array);
    var average = 0;
    for (var i = 0, lgth = array.length; i < lgth; ++i) {
      average += array[i];
    }

    var fixedAverage = (average / lgth) == 0 ? 1 : (average / lgth);

    return fixedAverage;
  };



  /**
   * Calculates the average amplitude of each frequency
   * @param array - array containing the amplitude of each frequency
   * @returns the average amplitude of all frequency
   */
  SongManager.prototype.getAverageVolume = function (array) {
    var values = 0;
    var average;
    var length = array.length;
    //console.log(length);
    // sum the frequency amplitudes
    for (var i = 0; i < length; i++) {
      values += array[i];
    }
    // then mean it
    average = values / length;
    return average;
  }



  /**
   * Calculate the intensity from the average of the 100 last sound values
   */
  SongManager.prototype.getSoundDataIntensity = function (arr) {
    var fixedAverage = this.getSoundDataAverage(arr);
    var i = 0;
    var totalSongAverage = 0;


    if (arr.length > 20) {
      this.allValues.shift();
      this.allValues.push(fixedAverage);
    } else {
      this.allValues.push(fixedAverage);
    }

    for (i = 0; i < this.allValues.length; i++) {
      totalSongAverage += this.allValues[i];
    };

    return (totalSongAverage / this.allValues.length).toFixed();
  };


  SongManager.prototype.getMicInput = function () {

    stopSound();
    //x-browser
    navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia;

    if (navigator.getUserMedia) {

      navigator.getUserMedia(

        {
          audio: true
        },

        function (stream) {

          //reinit here or get an echo on the mic
          this.sourceNode = audioContext.createBufferSource();
          this.analyser = audioContext.createAnalyser();
          this.analyser.fftSize = 1024;
          this.analyser.smoothingTimeConstant = 0.3;

          this.microphone = audioContext.createMediaStreamSource(stream);
          this.microphone.connect(this.analyser);
          isPlayingAudio = true;
          // console.log("here");
        },

        // errorCallback
        function (err) {
          alert("The following error occured: " + err);
        }
      );

    } else {
      alert("Could not getUserMedia");
    }
  }

  SongManager.prototype.stopSound = function () {
    //isPlayingAudio = false;
    if (this.sourceNode) {
      this.sourceNode.stop(0);
      this.sourceNode.disconnect();
    }
  }


  SongManager.prototype.doBeat = function (array, onBeat) {

    var level = this.getSoundDataAverage(array);
    // body...
    //BEAT DETECTION
    //console.log('beatMan', level, this.beatCutOff);
    if (level > this.beatCutOff && level > BEAT_MIN) {

      onBeat();
      this.beatCutOff = level * 1.1;
      beatTime = 0;
    } else {
      if (beatTime <= beatHoldTime) {
        beatTime++;
      } else {
        this.beatCutOff *= beatDecayRate;
        this.beatCutOff = Math.max(this.beatCutOff, BEAT_MIN);
      }
    }
  }



  SongManager.prototype.loadSong = function (url) {
    var audio = this.audio;
    if (audio) audio.remove();
    if (this.sourceNode) this.sourceNode.disconnect();
    //cancelAnimationFrame(audioAnimation);
    audio = new Audio();
    audio.src = url;
    audio.addEventListener("canplay", function (e) {
      setupAudioNodes();
    }, false);
  }

  return SongManager;

})();
/**
 * Makes a request to the Soundcloud API and returns the JSON data.
 */
var SoundcloudLoader = function (player, UI) {
    var self = this;
    var client_id = "15b0abc3b73c0a64fd45d2ef8fdbd06c"; // to get an ID go to http://developers.soundcloud.com/
    this.sound = {};
    this.streamUrl = "";
    this.errorMessage = "";
    this.player = player;
    this.UI = UI;

    /**
     * Loads the JSON stream data object from the URL of the track (as given in the location bar of the browser when browsing Soundcloud),
     * and on success it calls the callback passed to it (for example, used to then send the stream_url to the audiosource object).
     * @param track_url
     * @param callback
     */
    this.loadStream = function (track_url, successCallback, errorCallback) {
        SC.initialize({
            client_id: client_id
        });
        SC.get('/resolve', {
            url: track_url
        }, function (sound) {
            if (sound.errors) {
                self.errorMessage = "";
                for (var i = 0; i < sound.errors.length; i++) {
                    self.errorMessage += sound.errors[i].error_message + '<br>';
                }
                self.errorMessage += 'Make sure the URL has the correct format: https://soundcloud.com/user/title-of-the-track';
                errorCallback();
            } else {

                if (sound.kind == "playlist") {
                    self.sound = sound;
                    self.streamPlaylistIndex = 0;
                    self.streamUrl = function () {
                        return sound.tracks[self.streamPlaylistIndex].stream_url + '?client_id=' + client_id;
                    }
                    successCallback();
                } else {
                    self.sound = sound;
                    self.streamUrl = function () {
                        return sound.stream_url + '?client_id=' + client_id;
                    };
                    successCallback();
                }
            }
        });
    };


    this.directStream = function (direction) {
        if (direction == 'toggle') {
            if (this.player.paused) {
                this.player.play();
            } else {
                this.player.pause();
            }
        } else if (this.sound.kind == "playlist") {
            if (direction == 'coasting') {
                this.streamPlaylistIndex++;
            } else if (direction == 'forward') {
                if (this.streamPlaylistIndex >= this.sound.track_count - 1) this.streamPlaylistIndex = 0;
                else this.streamPlaylistIndex++;
            } else {
                if (this.streamPlaylistIndex <= 0) this.streamPlaylistIndex = this.sound.track_count - 1;
                else this.streamPlaylistIndex--;
            }
            if (this.streamPlaylistIndex >= 0 && this.streamPlaylistIndex <= this.sound.track_count - 1) {
                this.player.setAttribute('src', this.streamUrl());
                this.UI.update(this);
                this.player.play();
            }
        }
    }


};
/**
 * Class to update the UI when a new sound is loaded
 * @constructor
 */
var UIManager = function () {
	var controlPanel = document.getElementById('controlPanel');
	var trackInfoPanel = document.getElementById('trackInfoPanel');
	var infoImage = document.getElementById('infoImage');
	var infoArtist = document.getElementById('infoArtist');
	var infoTrack = document.getElementById('infoTrack');
	var messageBox = document.getElementById('messageBox');

	this.clearInfoPanel = function () {
		// first clear the current contents
		infoArtist.innerHTML = "";
		infoTrack.innerHTML = "";
		trackInfoPanel.className = 'hidden';
	};
	this.update = function (loader) {
		// update the track and artist into in the controlPanel
		var artistLink = document.createElement('a');
		artistLink.setAttribute('href', loader.sound.user.permalink_url);
		artistLink.innerHTML = loader.sound.user.username;
		var trackLink = document.createElement('a');
		trackLink.setAttribute('href', loader.sound.permalink_url);

		if (loader.sound.kind == "playlist") {
			trackLink.innerHTML = "<p>" + loader.sound.tracks[loader.streamPlaylistIndex].title + "</p>" + "<p>" + loader.sound.title + "</p>";
		} else {
			trackLink.innerHTML = loader.sound.title;
		}

		var image = loader.sound.artwork_url ? loader.sound.artwork_url : loader.sound.user.avatar_url; // if no track artwork exists, use the user's avatar.
		infoImage.setAttribute('src', image);

		infoArtist.innerHTML = '';
		infoArtist.appendChild(artistLink);

		infoTrack.innerHTML = '';
		infoTrack.appendChild(trackLink);

		// display the track info panel
		trackInfoPanel.className = '';

		// add a hash to the URL so it can be shared or saved
		var trackToken = loader.sound.permalink_url.substr(22);
		window.location = '#' + trackToken;
	};
	this.toggleControlPanel = function () {
		if (controlPanel.className.indexOf('hidden') === 0) {
			controlPanel.className = '';
		} else {
			controlPanel.className = 'hidden';
		}
	};
	this.displayMessage = function (title, message) {
		messageBox.innerHTML = ''; // reset the contents

		var titleElement = document.createElement('h3');
		titleElement.innerHTML = title;

		var messageElement = document.createElement('p');
		messageElement.innerHTML = message;

		var closeButton = document.createElement('a');
		closeButton.setAttribute('href', '#');
		closeButton.innerHTML = 'close';
		closeButton.addEventListener('click', function (e) {
			e.preventDefault();
			messageBox.className = 'hidden';
		});

		messageBox.className = '';
		// stick them into the container div
		messageBox.appendChild(titleElement);
		messageBox.appendChild(messageElement);
		messageBox.appendChild(closeButton);
	};
};
var webgl, sm, gui, clock, ui;

var baseURI = "https://soundcloud.com/bernardo-guerra/hiromi-uehara-dan-ando-no-para?in=glenn-sonna-hall/sets/nujasamples";
//https://soundcloud.com/hydeout-productions/luvsic-part6-remix 

function init() {


	webgl = new Webgl(window.innerWidth, window.innerHeight);
	ui = new UIManager();
	ui.toggleControlPanel();

	//gui = new dat.GUI();
	//gui.close();

	$(window).on('resize', resizeHandler);

	var clock = new THREE.Clock();

	sm = new SongManager(ui);
	sm.load(function () {
		animate();
		sm.loadAndUpdate(baseURI);
	});

	var form = document.getElementById('form');
	form.addEventListener('submit', function (e) {
		e.preventDefault();
		var trackUrl = document.getElementById('input').value;
		sm.loadAndUpdate(trackUrl);
	});
}

function resizeHandler() {
	webgl.resize(window.innerWidth, window.innerHeight);
}

function animate() {
	requestAnimationFrame(animate);
	webgl.render(sm);
}

function onDocumentMouseDown(event) {
	webgl.onDocumentMouseDown(event)
}

$(document).ready(init);
$('.three').mousedown(onDocumentMouseDown);
$('#controlPanel').hover(function () {
	ui.toggleControlPanel();
});
var Webgl = (function () {
    // parameters
    var SEPARATION = 25;
    var AMOUNTX = 50;
    var AMOUNTY = 50;
    var INITIAL_FACTOR = 1.0;
    var WAVE_HEIGHT = 200;
    var WAVE_SPEED = 0.2;
    var ROTATION_SPEED = 0.1;
    var DAMP_SPEED = 0.005;
    var CAMERA_SPEED = 0.05;

    var CAMERA_SPEED = 0.05;
    var CAMERA_INITIAL_X = -600;
    var CAMERA_INITIAL_Y = 1500;
    var CAMERA_INITIAL_Z = 3703;



    var LINES_HEIGHT = 10;

    var rotation = 0;
    var mouseX = -300;
    var mouseY = -300;



    var attributes = {

        size: {
            type: 'f',
            value: []
        },

        customColor: {
            type: 'c',
            value: []
        }
    };

    var uniforms = {

        amplitude: {
            type: "f",
            value: 1.0
        },
        color: {
            type: "c",
            value: new THREE.Color(0xffffff)
        },
        texture: {
            type: "t",
            value: THREE.ImageUtils.loadTexture("./src/js/img/particle.png")
        },
    };

    function Webgl(width, height) {
        // Basic three.js setup

        var worldWidth = 256,
            worldDepth = 256,
            worldHalfWidth = worldWidth / 2,
            worldHalfDepth = worldDepth / 2;

        this.canJumpTime = 0;
        this.bigTime = false;
        this.calming = false;

        this.factor = INITIAL_FACTOR;
        this.objects = [];
        this.particles = [];
        this.points = [];
        this.scene = new THREE.Scene();
        //this.scene.fog = new THREE.FogExp2(0x2D2D2D, 0.0000675);
        this.scene.fog = new THREE.FogExp2(0x000104, 0.0000675);
        this.raycaster = new THREE.Raycaster();

        this.camera = new THREE.PerspectiveCamera(50, width / height, 1, 100000);
        this.camera.position.x = CAMERA_INITIAL_X;
        this.camera.position.y = CAMERA_INITIAL_Y;
        this.camera.position.z = CAMERA_INITIAL_Z;

        this.camera.rotation = new THREE.Euler(-0.2998598927782072, -0.16611777185981183, -0.05108038192443367, 'XYZ');


        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(width, height);
        this.renderer.autoClear = false;
        this.renderer.setClearColor(this.scene.fog.color, 1);
        $('.three').append(this.renderer.domElement);

        this.controls = new THREE.OrbitControls(this.camera, this.renderer.domElement);
        this.controls.damping = 0.2;

        /*this.controls = new THREE.FlyControls(this.camera);

        this.controls.movementSpeed = 1000;
        this.controls.domElement = container;
        this.controls.rollSpeed = Math.PI / 24;
        this.controls.autoForward = false;
        this.controls.dragToLook = false;*/

        //Terrain
        this.terrainMesh = this.buildTerrainMesh(256, 256);

        //sky
        //this.sky = new THREE.Sky();
        //this.scene.add(this.sky.mesh);


        //Intiate 

        //this.calculateInitialPoints();
        //this.updatePoints();

        // Directly add objects
        this.scene.add(this.terrainMesh);
        this.objects.push(this.terrainMesh);



        //ProposPorcessing

        this.composer = new THREE.EffectComposer(this.renderer);

        var renderModel = new THREE.RenderPass(this.scene, this.camera);
        this.composer.addPass(renderModel);

        this.effectBloom = new THREE.BloomPass(1.3);
        this.effectBloom.renderToScreen = true;

        //this.effectBloom.blurX = 100;

        //new THREE.Vector2(0.001953125, 0.0);


        this.composer.addPass(this.effectBloom);


        this.effectFXAA = new THREE.ShaderPass(THREE.FXAAShader);
        this.effectFXAA.uniforms['resolution'].value.set(1 / width, 1 / height);
        //this.effectFXAA.renderToScreen = true;
        this.composer.addPass(this.effectFXAA);

        //Blurs
        var blurValue = 1 / 16;
        var tweenLength = 4;

        this.hBlurPass = new THREE.ShaderPass(THREE.HorizontalBlurShader);
        this.hBlurPass.uniforms['h'].value = 0;
        this.composer.addPass(this.hBlurPass);

        this.vBlurPass = new THREE.ShaderPass(THREE.VerticalBlurShader);
        this.vBlurPass.uniforms['v'].value = 0;
        this.composer.addPass(this.vBlurPass);

        TweenMax.from(this.hBlurPass.uniforms.h, tweenLength, {
            value: blurValue
        });
        TweenMax.from(this.vBlurPass.uniforms.v, tweenLength, {
            value: blurValue
        });

        //End Blurs

        this.effectCopy = new THREE.ShaderPass(THREE.CopyShader);
        this.effectCopy.renderToScreen = true;
        this.composer.addPass(this.effectCopy);

        //this.effectFilm = new THREE.FilmPass(0.5, 0.5, 1448, false);
        //this.effectFilm.renderToScreen = true;
        //this.composer.addPass(this.effectFilm);

        /* this.effectFocus = new THREE.ShaderPass(THREE.FocusShader);
        this.effectFocus.uniforms["screenWidth"].value = width;
        this.effectFocus.uniforms["screenHeight"].value = height;
        this.effectFocus.renderToScreen = true;
        this.composer.addPass(this.effectFocus);*/

    }



    Webgl.prototype.buildTerrainMesh = function (worldWidth, worldDepth) {
        var geometry = new THREE.PlaneBufferGeometry(50000, 50000, worldWidth - 1, worldDepth - 1);
        geometry.applyMatrix(new THREE.Matrix4().makeRotationX(Math.PI / 4));



        var vertices = geometry.attributes.position.array;

        var data = this.generateHeight(256, 256);
        var basePos = new Float32Array(vertices.length);


        for (var i = 0, j = 0, l = vertices.length; i < l; i++, j += 3) {

            vertices[j + 1] = data[i] * 10;
            basePos[j + 0] = vertices[j + 0];
            basePos[j + 1] = vertices[j + 1];
            basePos[j + 2] = vertices[j + 2];
        }

        geometry.addAttribute('basePos', new THREE.BufferAttribute(basePos, 1));

        //geometry.addAttribute('pushed', new THREE.BufferAttribute(values_pushed, 1));

        this.drawParticles(geometry);

        var material = new THREE.MeshBasicMaterial({
            color: 0x448844,
            shading: THREE.FlatShading,
            wireframe: false,
            wireframeLinewidth: 2,
            transparent: true
        });


        var mesh = new THREE.Mesh(geometry, material);
        //mesh.visible = false;
        return mesh;

    }

    Webgl.prototype.drawParticles = function (geometry) {
        this.geometry = geometry;
        this.lineAvgGeometry = new THREE.Geometry();
        this.lgeometry = new THREE.Geometry();
        this.lBassGeometry = new THREE.Geometry();

        var add = true,
            colors = [],
            particle, material = new THREE.ShaderMaterial({

                uniforms: uniforms,
                attributes: attributes,
                vertexShader: document.getElementById('vertexshader').textContent,
                fragmentShader: document.getElementById('fragmentshader').textContent,
                transparent: true,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                opacity: 0.7,
                // vertexColors: THREE.VertexColors,
            }),
            vertices = this.geometry.attributes.position.array,
            p = [3.5, 0xffffff, 0.5, 7],
            lmaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                opacity: 1,
                linewidth: p[3],
                vertexColors: THREE.VertexColors
            }),
            lAvgMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                opacity: 1,
                linewidth: 10,
                vertexColors: THREE.VertexColors
            }),
            lBassMaterial = new THREE.LineBasicMaterial({
                color: 0xffffff,
                opacity: 1,
                linewidth: 20,
                vertexColors: THREE.VertexColors
            });;


        var direction = new Float32Array(vertices.length);
        var positions = new Float32Array(vertices.length * 3);
        var values_color = new Float32Array(vertices.length * 3);
        var values_size = new Float32Array(vertices.length);
        var baseSize = new Float32Array(vertices.length);
        //var basePos= new Float32Array(vertices.length);

        var mover = new Float32Array(vertices.length);
        var scaler = new Float32Array(vertices.length);
        var liner = new Float32Array(vertices.length);

        //Freq data
        var frequency = new Float32Array(vertices.length);
        var color = new THREE.Color(0xffaa00);

        var linePositions = new Float32Array(vertices.length * 6);
        var linesColors = [];
        var linesAvgColors = [];
        var linesBassColors = [];

        for (var v = 0; v < vertices.length; v++) {

            //Particle type definition
            var isMover = Math.random() >= 0.50;
            var isLiner = Math.random() >= 0.99;


            liner[v] = isLiner;

            if (!isLiner) {
                mover[v] = isMover;
                scaler[v] = !isMover;
            }

            //PArticle size deifnition
            var size = Math.floor(Math.random() * 100) + 15;
            values_size[v] = size;
            baseSize[v] = size;


            //Particle Color definition
            values_color[v * 3 + 0] = color.r;
            values_color[v * 3 + 1] = color.g;
            values_color[v * 3 + 2] = color.b;

            if (vertices[v] < 0)
                color.setHSL(0.5 + 0.1 * (v / vertices.length), 0.7, 0.5);
            else
                color.setHSL(0.0 + 0.1 * (v / vertices.length), 0.9, 0.5);

            //Particles associated lines
            if (isLiner) {
                var isBass = Math.random() >= 0.70;
                var isAvg = Math.random() >= 0.40;


                var lgeometry = this.lBassGeometry;
                if (isAvg) {
                    if (isBass) {
                        var lbColor = new THREE.Color(0xE8590C);

                        if (v % 2 != 1)
                            lbColor.setHSL(0.1 + 0.1 * (v / vertices.length), 0.7, 0.5);
                        linesBassColors.push(lbColor);

                    } else {
                        lgeometry = this.lineAvgGeometry
                        var lacolor = new THREE.Color(0x440DFF);

                        if (v % 2 != 1)
                            lacolor.setHSL(0.1 + 0.1 * (v / vertices.length), 0.7, 0.5);

                        linesAvgColors.push(lacolor);
                    }
                } else {
                    lgeometry = this.lgeometry
                    var lcolor = new THREE.Color(0xffffff);

                    if (v % 2 != 1)
                        lcolor.setHSL(0.5 + 0.1 * (v / vertices.length), 0.7, 0.5);
                    else
                        lcolor.setHSL(0.0 + 0.1 * (v / vertices.length), 0.9, 0.5);

                    linesColors.push(lcolor);
                }

                var vertex1 = new THREE.Vector3();
                vertex1.x = vertices[v * 3 + 0];
                vertex1.y = vertices[v * 3 + 1];
                vertex1.z = vertices[v * 3 + 2];


                var vertex2 = vertex1.clone();
                vertex2.y += LINES_HEIGHT;
                vertex2.baseY = vertices[v * 3 + 1] + LINES_HEIGHT;

                lgeometry.vertices.push(vertex1);
                lgeometry.vertices.push(vertex2);
            }
        }

        this.lBassGeometry.colors = linesBassColors;
        this.lineAvgGeometry.colors = linesAvgColors;
        this.lgeometry.colors = linesColors;

        //this.geometry.addAttribute('position', new THREE.BufferAttribute(positions, 3));
        this.geometry.addAttribute('customColor', new THREE.BufferAttribute(values_color, 3));
        this.geometry.addAttribute('size', new THREE.BufferAttribute(values_size, 1));
        this.geometry.addAttribute('baseSize', new THREE.BufferAttribute(baseSize, 1));
        this.geometry.addAttribute('direction', new THREE.BufferAttribute(direction, 1));

        //Add types
        this.geometry.addAttribute('liner', new THREE.BufferAttribute(liner, 1));
        this.geometry.addAttribute('mover', new THREE.BufferAttribute(mover, 1));
        this.geometry.addAttribute('scaler', new THREE.BufferAttribute(scaler, 1));
        this.geometry.addAttribute('frequency', new THREE.BufferAttribute(frequency, 1));

        this.line = new THREE.Line(this.lgeometry, lmaterial, THREE.LinePieces);
        this.lineAvg = new THREE.Line(this.lineAvgGeometry, lAvgMaterial, THREE.LinePieces);
        this.lineBass = new THREE.Line(this.lBassGeometry, lBassMaterial, THREE.LinePieces);
        //this.line.scale.x = this.line.scale.y = this.line.scale.z = p[0];
        //this.line.originalScale = p[0];
        this.scene.add(this.line);
        this.scene.add(this.lineAvg);
        this.scene.add(this.lineBass);



        console.log(this.geometry);
        var pointcloud = new THREE.PointCloud(this.geometry, material);
        pointcloud.dynamic = true;

        this.scene.add(pointcloud);

    }


    Webgl.prototype.generateHeight = function (width, height) {

        var size = width * height,
            data = new Uint8Array(size),
            perlin = new ImprovedNoise(),
            quality = 1,
            z = Math.random() * 100;

        for (var j = 0; j < 4; j++) {

            for (var i = 0; i < size; i++) {

                var x = i % width,
                    y = ~~ (i / width);
                data[i] += Math.abs(perlin.noise(x / quality, y / quality, z) * quality * 1.75);

            }

            quality *= 5;

        }

        return data;
    }

    Webgl.prototype.onDocumentMouseDown = function (event) {

        event.preventDefault();

        var vector = new THREE.Vector3();
        vector.set((event.clientX / window.innerWidth) * 2 - 1, -(event.clientY / window.innerHeight) * 2 + 1, 0.5);
        vector.unproject(this.camera);

        this.raycaster.ray.set(this.camera.position, vector.sub(this.camera.position).normalize());

        var intersects = this.raycaster.intersectObjects(this.objects);

        this.actor = INITIAL_FACTOR;
        if (intersects.length > 0) {

            //intersects[0].object.material.color.setHex(Math.random() * 0xffffff);

            //var particle = new THREE.Sprite(particleMaterial);
            //particle.position.copy(intersects[0].point);
            //particle.scale.x = particle.scale.y = 16;
            //this.scene.add(particle);

            //console.log(intersects[0].point);
        }
    }


    Webgl.prototype.calculateNextParameters = function () {
        rotation += ROTATION_SPEED;
        if (this.factor > 0) {
            this.factor -= DAMP_SPEED;
        }
    }

    Webgl.prototype.calculateInitialPoints = function () {
        for (var i = 0; i < this.geometry.vertices.length; i++) {
            var v = this.geometry.vertices[i];
            var x = (v.x /
                SEPARATION) * WAVE_SPEED;
            var y = (v.y / SEPARATION) * WAVE_SPEED;
            this.points[i] = WAVE_HEIGHT * (Math.cos(x * x + y * y) / Math.sqrt(x * x + y * y + 0.25));
        }
    }

    Webgl.prototype.render = function (songman) {



        var time = Date.now() * 0.005;
        this.songdata = new Uint8Array(songman.analyser.frequencyBinCount);
        songman.analyser.getByteFrequencyData(this.songdata);

        this.updatePoints(time, songman);
        this.upDateLines(time, songman);
        this.updateCamera(time, songman);
        songman.render();

        this.geometry.computeFaceNormals();
        this.geometry.computeVertexNormals();

        this.lBassGeometry.verticesNeedUpdate = true;
        this.lineAvgGeometry.verticesNeedUpdate = true;
        this.lgeometry.verticesNeedUpdate = true;

        this.geometry.attributes.size.needsUpdate = true;
        this.geometry.attributes.position.needsUpdate = true;
        this.geometry.attributes.customColor.needsUpdate = true;

        this.composer.render();
        //this.renderer.render(this.scene, this.camera);
        //console.log("intensity %s | volume : %s [ avg  : %s", intensity, volume, avg);
    };

    Webgl.prototype.updateCamera = function (time, songman) {
        var intensity = songman.getSoundDataIntensity(this.songdata);
        this.camera.position.x = Math.cos(time * 0.01) * 20000;
        this.camera.position.z = Math.sin(time * 0.01) * 20000;
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));

        if ((this.bigTime == true) && (this.camera.position.y <= CAMERA_INITIAL_Y + 100) && this.canJumpTime <= 2) {
            TweenMax.from(this.camera.position, 5, {
                y: CAMERA_INITIAL_Y + 5000
            });

        } else if (this.calming == true && this.camera.position.y > CAMERA_INITIAL_Y + 5000) {

            /*TweenMax.from(this.camera.position, 10, {
                y: CAMERA_INITIAL_Y
            });*/
        }
    }

    Webgl.prototype.updatePoints = function (time, songman) {

        var size = this.geometry.attributes.size.array;
        var vertice = this.geometry.attributes.position.array;
        var colors = this.geometry.attributes.customColor;
        var direction = this.geometry.attributes.direction.array;
        var baseSize = this.geometry.attributes.baseSize.array;
        var basePos = this.geometry.attributes.basePos.array;

        var mover = this.geometry.attributes.mover.array;
        var scaler = this.geometry.attributes.scaler.array;
        var liner = this.geometry.attributes.liner.array;

        var frequency = this.geometry.attributes.frequency.array;

        var avg = songman.getSoundDataAverage(this.songdata);

        var intensity = songman.getSoundDataIntensity(this.songdata);
        var volume = songman.getAverageVolume(this.songdata);

        var $$ = this;
        songman.doBeat(this.songdata, function () {
            $$.terrainMesh.material.color.setHex(Math.random() * 0xffffff);
        });

        this.bigTime = (intensity > 79);
        if (this.bigTime) {
            this.canJumpTime++
        } else if (this.caJumpTime > 15) {
            //this.calming = true;
            this.bigTime = false;
            this.canJumpTime = 0
        }

        for (var i = 0, j = 0, l = vertice.length; i < l; i++, j += 3) {

            if (frequency[i] === 0) {
                frequency[i] = Math.floor(Math.random() * this.songdata.length / 2);
            }

            //this.songdata[frequency[i]];
            //this.songdata[i % this.songdata.length];

            //___Particles jump
            var avgDestValue = (basePos[j + 1] + avg) * 3;

            if (scaler[i]) {
                //var vertDestValue = baseSize[i] + (this.bigTime ? avg + (baseSize[i] / 2) : (avg / 1.99));
                //size[i] += (vertDestValue - size[i]) * 0.6;
                //size[i] = 14 + 13 * Math.sin(0.1 * i + time);
            } else {


                //this.caJumpTime = this.bigTime ? this.canJumpTime++ : this.caJumpTime > 15 ? 0;

                //75 for more tolerance
                var vertDestValue = basePos[j + 1] + (this.bigTime ? avg + (basePos[j + 1] / 2) : (avg / 1.5));
                vertice[j + 1] += (vertDestValue - vertice[j + 1]) * 0.6;

                //move(vertice[j + 1], basePos[j + 1], direction[i]);
            }
        }
    }

    //___Lines jump
    Webgl.prototype.upDateLines = function (time, songman) {

        var avg = songman.getSoundDataAverage(this.songdata);
        var intensity = songman.getSoundDataIntensity(this.songdata);
        var volume = songman.getAverageVolume(this.songdata);

        var lines = this.lgeometry.vertices;
        var linesAvg = this.lineAvgGeometry.vertices;
        var linesBass = this.lBassGeometry.vertices;

        //intensity > 80 && console.log(this.songdata);

        for (var i = 0; i < lines.length; i += 2) {

            //pick a random indice in array could be : (i % this.songdata.length);
            if (!lines[i + 1].hasOwnProperty('note'))
                lines[i + 1].note = Math.floor(Math.random() * this.songdata.length / 2);

            var songD = this.songdata[lines[i + 1].note];
            if (lines[i + 1]) {
                var value = lines[i + 1].baseY + (LINES_HEIGHT + (songD * 15));
                lines[i + 1].y += (value - lines[i + 1].y) * 0.6;
            }
        };

        for (var i = 0; i < linesAvg.length; i += 2) {

            var multiplier = intensity > 80 ? intensity : 1;

            var songD = this.songdata[i % this.songdata.length];
            if (linesAvg[i + 1]) {
                var value = linesAvg[i + 1].baseY + (((LINES_HEIGHT * 1.5) + (avg * 30)) * (avg / avg));
                linesAvg[i + 1].y += (value - linesAvg[i + 1].y) * 0.6;
            }
        };

        //TODO : indice attribute value to line
        //Bass
        for (var i = 0; i < linesBass.length; i += 2) {

            var songD = this.songdata[Math.floor(Math.random() * 5) + 1];
            if (linesBass[i + 1]) {
                var value = linesBass[i + 1].baseY + (1 * songD);
                linesBass[i + 1].y += (value - linesBass[i + 1].y) * 0.6;
            }
        };
    }

    //this.move(vertice[j + 1], basePos[j + 1], direction[i]);
    Webgl.prototype.move = function (vertice, base, direction) {
        if (vertice == base) {
            direction = 1;
        } else if (vertice == base + 30) {
            direction = -1;
        }
        vertice = vertice + direction;



        if (vertice[j + 1] == basePos[j + 1]) {
            direction[i] = 1;
        } else if (vertice[j + 1] == basePos[j + 1] + 30) {
            direction[i] = -1;
        }
        vertice[j + 1] = vertice[j + 1] + direction[i];
    };

    Webgl.prototype.scale = function (width, height) {
        //vertice[j + 1] = basePos[j + 1] * Math.sin(j / 5 + (time + j) / 7);
        //size[i] = 14 + 13 * Math.sin(0.1 * i + time);
        if (size[i] <= 1) {
            direction[i] = 1;
        } else if (size[i] == baseSize[i]) {
            direction[i] = -1;
        }
        size[i] += direction[i];
    };


    Webgl.prototype.resize = function (width, height) {
        this.camera.aspect = width / height;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(width, height);
        this.composer.reset();

        //this.controls.handleResize();
    };


    return Webgl;

})();
/**
 * @author James Baicoianu / http://www.baicoianu.com/
 */

THREE.FlyControls = function (object, domElement) {

	this.object = object;

	this.domElement = (domElement !== undefined) ? domElement : document;
	if (domElement) this.domElement.setAttribute('tabindex', -1);

	// API

	this.movementSpeed = 1.0;
	this.rollSpeed = 0.005;

	this.dragToLook = false;
	this.autoForward = false;

	// disable default target object behavior

	// internals

	this.tmpQuaternion = new THREE.Quaternion();

	this.mouseStatus = 0;

	this.moveState = {
		up: 0,
		down: 0,
		left: 0,
		right: 0,
		forward: 0,
		back: 0,
		pitchUp: 0,
		pitchDown: 0,
		yawLeft: 0,
		yawRight: 0,
		rollLeft: 0,
		rollRight: 0
	};
	this.moveVector = new THREE.Vector3(0, 0, 0);
	this.rotationVector = new THREE.Vector3(0, 0, 0);

	this.handleEvent = function (event) {

		if (typeof this[event.type] == 'function') {

			this[event.type](event);

		}

	};

	this.keydown = function (event) {

		if (event.altKey) {

			return;

		}

		//event.preventDefault();

		switch (event.keyCode) {

		case 16:
			/* shift */
			this.movementSpeedMultiplier = .1;
			break;

		case 87:
			/*W*/
			this.moveState.forward = 1;
			break;
		case 83:
			/*S*/
			this.moveState.back = 1;
			break;

		case 65:
			/*A*/
			this.moveState.left = 1;
			break;
		case 68:
			/*D*/
			this.moveState.right = 1;
			break;

		case 82:
			/*R*/
			this.moveState.up = 1;
			break;
		case 70:
			/*F*/
			this.moveState.down = 1;
			break;

		case 38:
			/*up*/
			this.moveState.pitchUp = 1;
			break;
		case 40:
			/*down*/
			this.moveState.pitchDown = 1;
			break;

		case 37:
			/*left*/
			this.moveState.yawLeft = 1;
			break;
		case 39:
			/*right*/
			this.moveState.yawRight = 1;
			break;

		case 81:
			/*Q*/
			this.moveState.rollLeft = 1;
			break;
		case 69:
			/*E*/
			this.moveState.rollRight = 1;
			break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	};

	this.keyup = function (event) {

		switch (event.keyCode) {

		case 16:
			/* shift */
			this.movementSpeedMultiplier = 1;
			break;

		case 87:
			/*W*/
			this.moveState.forward = 0;
			break;
		case 83:
			/*S*/
			this.moveState.back = 0;
			break;

		case 65:
			/*A*/
			this.moveState.left = 0;
			break;
		case 68:
			/*D*/
			this.moveState.right = 0;
			break;

		case 82:
			/*R*/
			this.moveState.up = 0;
			break;
		case 70:
			/*F*/
			this.moveState.down = 0;
			break;

		case 38:
			/*up*/
			this.moveState.pitchUp = 0;
			break;
		case 40:
			/*down*/
			this.moveState.pitchDown = 0;
			break;

		case 37:
			/*left*/
			this.moveState.yawLeft = 0;
			break;
		case 39:
			/*right*/
			this.moveState.yawRight = 0;
			break;

		case 81:
			/*Q*/
			this.moveState.rollLeft = 0;
			break;
		case 69:
			/*E*/
			this.moveState.rollRight = 0;
			break;

		}

		this.updateMovementVector();
		this.updateRotationVector();

	};

	this.mousedown = function (event) {

		if (this.domElement !== document) {

			this.domElement.focus();

		}

		event.preventDefault();
		event.stopPropagation();

		if (this.dragToLook) {

			this.mouseStatus++;

		} else {

			switch (event.button) {

			case 0:
				this.moveState.forward = 1;
				break;
			case 2:
				this.moveState.back = 1;
				break;

			}

			this.updateMovementVector();

		}

	};

	this.mousemove = function (event) {

		if (!this.dragToLook || this.mouseStatus > 0) {

			var container = this.getContainerDimensions();
			var halfWidth = container.size[0] / 2;
			var halfHeight = container.size[1] / 2;

			this.moveState.yawLeft = -((event.pageX - container.offset[0]) - halfWidth) / halfWidth;
			this.moveState.pitchDown = ((event.pageY - container.offset[1]) - halfHeight) / halfHeight;

			this.updateRotationVector();

		}

	};

	this.mouseup = function (event) {

		event.preventDefault();
		event.stopPropagation();

		if (this.dragToLook) {

			this.mouseStatus--;

			this.moveState.yawLeft = this.moveState.pitchDown = 0;

		} else {

			switch (event.button) {

			case 0:
				this.moveState.forward = 0;
				break;
			case 2:
				this.moveState.back = 0;
				break;

			}

			this.updateMovementVector();

		}

		this.updateRotationVector();

	};

	this.update = function (delta) {

		var moveMult = delta * this.movementSpeed;
		var rotMult = delta * this.rollSpeed;

		this.object.translateX(this.moveVector.x * moveMult);
		this.object.translateY(this.moveVector.y * moveMult);
		this.object.translateZ(this.moveVector.z * moveMult);

		this.tmpQuaternion.set(this.rotationVector.x * rotMult, this.rotationVector.y * rotMult, this.rotationVector.z * rotMult, 1).normalize();
		this.object.quaternion.multiply(this.tmpQuaternion);

		// expose the rotation vector for convenience
		this.object.rotation.setFromQuaternion(this.object.quaternion, this.object.rotation.order);


	};

	this.updateMovementVector = function () {

		var forward = (this.moveState.forward || (this.autoForward && !this.moveState.back)) ? 1 : 0;

		this.moveVector.x = (-this.moveState.left + this.moveState.right);
		this.moveVector.y = (-this.moveState.down + this.moveState.up);
		this.moveVector.z = (-forward + this.moveState.back);

		//console.log( 'move:', [ this.moveVector.x, this.moveVector.y, this.moveVector.z ] );

	};

	this.updateRotationVector = function () {

		this.rotationVector.x = (-this.moveState.pitchDown + this.moveState.pitchUp);
		this.rotationVector.y = (-this.moveState.yawRight + this.moveState.yawLeft);
		this.rotationVector.z = (-this.moveState.rollRight + this.moveState.rollLeft);

		//console.log( 'rotate:', [ this.rotationVector.x, this.rotationVector.y, this.rotationVector.z ] );

	};

	this.getContainerDimensions = function () {

		if (this.domElement != document) {

			return {
				size: [this.domElement.offsetWidth, this.domElement.offsetHeight],
				offset: [this.domElement.offsetLeft, this.domElement.offsetTop]
			};

		} else {

			return {
				size: [window.innerWidth, window.innerHeight],
				offset: [0, 0]
			};

		}

	};

	function bind(scope, fn) {

		return function () {

			fn.apply(scope, arguments);

		};

	};

	this.domElement.addEventListener('contextmenu', function (event) {
		event.preventDefault();
	}, false);

	this.domElement.addEventListener('mousemove', bind(this, this.mousemove), false);
	this.domElement.addEventListener('mousedown', bind(this, this.mousedown), false);
	this.domElement.addEventListener('mouseup', bind(this, this.mouseup), false);

	window.addEventListener('keydown', bind(this, this.keydown), false);
	window.addEventListener('keyup', bind(this, this.keyup), false);

	this.updateMovementVector();
	this.updateRotationVector();

};
/**
 * @author qiao / https://github.com/qiao
 * @author mrdoob / http://mrdoob.com
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author erich666 / http://erichaines.com
 */
/*global THREE, console */

// This set of controls performs orbiting, dollying (zooming), and panning. It maintains
// the "up" direction as +Y, unlike the TrackballControls. Touch on tablet and phones is
// supported.
//
//    Orbit - left mouse / touch: one finger move
//    Zoom - middle mouse, or mousewheel / touch: two finger spread or squish
//    Pan - right mouse, or arrow keys / touch: three finter swipe
//
// This is a drop-in replacement for (most) TrackballControls used in examples.
// That is, include this js file and wherever you see:
//    	controls = new THREE.TrackballControls( camera );
//      controls.target.z = 150;
// Simple substitute "OrbitControls" and the control should work as-is.

THREE.OrbitControls = function (object, domElement) {

	this.object = object;
	this.domElement = (domElement !== undefined) ? domElement : document;

	// API

	// Set to false to disable this control
	this.enabled = true;

	// "target" sets the location of focus, where the control orbits around
	// and where it pans with respect to.
	this.target = new THREE.Vector3();

	// center is old, deprecated; use "target" instead
	this.center = this.target;

	// This option actually enables dollying in and out; left as "zoom" for
	// backwards compatibility
	this.noZoom = false;
	this.zoomSpeed = 1.0;

	// Limits to how far you can dolly in and out
	this.minDistance = 0;
	this.maxDistance = Infinity;

	// Set to true to disable this control
	this.noRotate = false;
	this.rotateSpeed = 1.0;

	// Set to true to disable this control
	this.noPan = false;
	this.keyPanSpeed = 7.0; // pixels moved per arrow key push

	// Set to true to automatically rotate around the target
	this.autoRotate = false;
	this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

	// How far you can orbit vertically, upper and lower limits.
	// Range is 0 to Math.PI radians.
	this.minPolarAngle = 0; // radians
	this.maxPolarAngle = Math.PI; // radians

	// How far you can orbit horizontally, upper and lower limits.
	// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
	this.minAzimuthAngle = -Infinity; // radians
	this.maxAzimuthAngle = Infinity; // radians

	// Set to true to disable use of the keys
	this.noKeys = false;

	// The four arrow keys
	this.keys = {
		LEFT: 37,
		UP: 38,
		RIGHT: 39,
		BOTTOM: 40
	};

	// Mouse buttons
	this.mouseButtons = {
		ORBIT: THREE.MOUSE.LEFT,
		ZOOM: THREE.MOUSE.MIDDLE,
		PAN: THREE.MOUSE.RIGHT
	};

	////////////
	// internals

	var scope = this;

	var EPS = 0.000001;

	var rotateStart = new THREE.Vector2();
	var rotateEnd = new THREE.Vector2();
	var rotateDelta = new THREE.Vector2();

	var panStart = new THREE.Vector2();
	var panEnd = new THREE.Vector2();
	var panDelta = new THREE.Vector2();
	var panOffset = new THREE.Vector3();

	var offset = new THREE.Vector3();

	var dollyStart = new THREE.Vector2();
	var dollyEnd = new THREE.Vector2();
	var dollyDelta = new THREE.Vector2();

	var phiDelta = 0;
	var thetaDelta = 0;
	var scale = 1;
	var pan = new THREE.Vector3();

	var lastPosition = new THREE.Vector3();
	var lastQuaternion = new THREE.Quaternion();

	var STATE = {
		NONE: -1,
		ROTATE: 0,
		DOLLY: 1,
		PAN: 2,
		TOUCH_ROTATE: 3,
		TOUCH_DOLLY: 4,
		TOUCH_PAN: 5
	};

	var state = STATE.NONE;

	// for reset

	this.target0 = this.target.clone();
	this.position0 = this.object.position.clone();

	// so camera.up is the orbit axis

	var quat = new THREE.Quaternion().setFromUnitVectors(object.up, new THREE.Vector3(0, 1, 0));
	var quatInverse = quat.clone().inverse();

	// events

	var changeEvent = {
		type: 'change'
	};
	var startEvent = {
		type: 'start'
	};
	var endEvent = {
		type: 'end'
	};

	this.rotateLeft = function (angle) {

		if (angle === undefined) {

			angle = getAutoRotationAngle();

		}

		thetaDelta -= angle;

	};

	this.rotateUp = function (angle) {

		if (angle === undefined) {

			angle = getAutoRotationAngle();

		}

		phiDelta -= angle;

	};

	// pass in distance in world space to move left
	this.panLeft = function (distance) {

		var te = this.object.matrix.elements;

		// get X column of matrix
		panOffset.set(te[0], te[1], te[2]);
		panOffset.multiplyScalar(-distance);

		pan.add(panOffset);

	};

	// pass in distance in world space to move up
	this.panUp = function (distance) {

		var te = this.object.matrix.elements;

		// get Y column of matrix
		panOffset.set(te[4], te[5], te[6]);
		panOffset.multiplyScalar(distance);

		pan.add(panOffset);

	};

	// pass in x,y of change desired in pixel space,
	// right and down are positive
	this.pan = function (deltaX, deltaY) {

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		if (scope.object.fov !== undefined) {

			// perspective
			var position = scope.object.position;
			var offset = position.clone().sub(scope.target);
			var targetDistance = offset.length();

			// half of the fov is center to top of screen
			targetDistance *= Math.tan((scope.object.fov / 2) * Math.PI / 180.0);

			// we actually don't use screenWidth, since perspective camera is fixed to screen height
			scope.panLeft(2 * deltaX * targetDistance / element.clientHeight);
			scope.panUp(2 * deltaY * targetDistance / element.clientHeight);

		} else if (scope.object.top !== undefined) {

			// orthographic
			scope.panLeft(deltaX * (scope.object.right - scope.object.left) / element.clientWidth);
			scope.panUp(deltaY * (scope.object.top - scope.object.bottom) / element.clientHeight);

		} else {

			// camera neither orthographic or perspective
			console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.');

		}

	};

	this.dollyIn = function (dollyScale) {

		if (dollyScale === undefined) {

			dollyScale = getZoomScale();

		}

		scale /= dollyScale;

	};

	this.dollyOut = function (dollyScale) {

		if (dollyScale === undefined) {

			dollyScale = getZoomScale();

		}

		scale *= dollyScale;

	};

	this.update = function () {

		var position = this.object.position;

		offset.copy(position).sub(this.target);

		// rotate offset to "y-axis-is-up" space
		offset.applyQuaternion(quat);

		// angle from z-axis around y-axis

		var theta = Math.atan2(offset.x, offset.z);

		// angle from y-axis

		var phi = Math.atan2(Math.sqrt(offset.x * offset.x + offset.z * offset.z), offset.y);

		if (this.autoRotate) {

			this.rotateLeft(getAutoRotationAngle());

		}

		theta += thetaDelta;
		phi += phiDelta;

		// restrict theta to be between desired limits
		theta = Math.max(this.minAzimuthAngle, Math.min(this.maxAzimuthAngle, theta));

		// restrict phi to be between desired limits
		phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, phi));

		// restrict phi to be betwee EPS and PI-EPS
		phi = Math.max(EPS, Math.min(Math.PI - EPS, phi));

		var radius = offset.length() * scale;

		// restrict radius to be between desired limits
		radius = Math.max(this.minDistance, Math.min(this.maxDistance, radius));

		// move target to panned location
		this.target.add(pan);

		offset.x = radius * Math.sin(phi) * Math.sin(theta);
		offset.y = radius * Math.cos(phi);
		offset.z = radius * Math.sin(phi) * Math.cos(theta);

		// rotate offset back to "camera-up-vector-is-up" space
		offset.applyQuaternion(quatInverse);

		position.copy(this.target).add(offset);

		this.object.lookAt(this.target);

		thetaDelta = 0;
		phiDelta = 0;
		scale = 1;
		pan.set(0, 0, 0);

		// update condition is:
		// min(camera displacement, camera rotation in radians)^2 > EPS
		// using small-angle approximation cos(x/2) = 1 - x^2 / 8

		if (lastPosition.distanceToSquared(this.object.position) > EPS || 8 * (1 - lastQuaternion.dot(this.object.quaternion)) > EPS) {

			this.dispatchEvent(changeEvent);

			lastPosition.copy(this.object.position);
			lastQuaternion.copy(this.object.quaternion);

		}

	};


	this.reset = function () {

		state = STATE.NONE;

		this.target.copy(this.target0);
		this.object.position.copy(this.position0);

		this.update();

	};

	function getAutoRotationAngle() {

		return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

	}

	function getZoomScale() {

		return Math.pow(0.95, scope.zoomSpeed);

	}

	function onMouseDown(event) {

		if (scope.enabled === false) return;
		event.preventDefault();

		if (event.button === scope.mouseButtons.ORBIT) {
			if (scope.noRotate === true) return;

			state = STATE.ROTATE;

			rotateStart.set(event.clientX, event.clientY);

		} else if (event.button === scope.mouseButtons.ZOOM) {
			if (scope.noZoom === true) return;

			state = STATE.DOLLY;

			dollyStart.set(event.clientX, event.clientY);

		} else if (event.button === scope.mouseButtons.PAN) {
			if (scope.noPan === true) return;

			state = STATE.PAN;

			panStart.set(event.clientX, event.clientY);

		}

		document.addEventListener('mousemove', onMouseMove, false);
		document.addEventListener('mouseup', onMouseUp, false);
		scope.dispatchEvent(startEvent);

	}

	function onMouseMove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		if (state === STATE.ROTATE) {

			if (scope.noRotate === true) return;

			rotateEnd.set(event.clientX, event.clientY);
			rotateDelta.subVectors(rotateEnd, rotateStart);

			// rotating across whole screen goes 360 degrees around
			scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);

			// rotating up and down along whole screen attempts to go 360, but limited to 180
			scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

			rotateStart.copy(rotateEnd);

		} else if (state === STATE.DOLLY) {

			if (scope.noZoom === true) return;

			dollyEnd.set(event.clientX, event.clientY);
			dollyDelta.subVectors(dollyEnd, dollyStart);

			if (dollyDelta.y > 0) {

				scope.dollyIn();

			} else {

				scope.dollyOut();

			}

			dollyStart.copy(dollyEnd);

		} else if (state === STATE.PAN) {

			if (scope.noPan === true) return;

			panEnd.set(event.clientX, event.clientY);
			panDelta.subVectors(panEnd, panStart);

			scope.pan(panDelta.x, panDelta.y);

			panStart.copy(panEnd);

		}

		scope.update();

	}

	function onMouseUp( /* event */ ) {

		if (scope.enabled === false) return;

		document.removeEventListener('mousemove', onMouseMove, false);
		document.removeEventListener('mouseup', onMouseUp, false);
		scope.dispatchEvent(endEvent);
		state = STATE.NONE;

	}

	function onMouseWheel(event) {

		if (scope.enabled === false || scope.noZoom === true) return;

		event.preventDefault();
		event.stopPropagation();

		var delta = 0;

		if (event.wheelDelta !== undefined) { // WebKit / Opera / Explorer 9

			delta = event.wheelDelta;

		} else if (event.detail !== undefined) { // Firefox

			delta = -event.detail;

		}

		if (delta > 0) {

			scope.dollyOut();

		} else {

			scope.dollyIn();

		}

		scope.update();
		scope.dispatchEvent(startEvent);
		scope.dispatchEvent(endEvent);

	}

	function onKeyDown(event) {

		if (scope.enabled === false || scope.noKeys === true || scope.noPan === true) return;

		switch (event.keyCode) {

		case scope.keys.UP:
			scope.pan(0, scope.keyPanSpeed);
			scope.update();
			break;

		case scope.keys.BOTTOM:
			scope.pan(0, -scope.keyPanSpeed);
			scope.update();
			break;

		case scope.keys.LEFT:
			scope.pan(scope.keyPanSpeed, 0);
			scope.update();
			break;

		case scope.keys.RIGHT:
			scope.pan(-scope.keyPanSpeed, 0);
			scope.update();
			break;

		}

	}

	function touchstart(event) {

		if (scope.enabled === false) return;

		switch (event.touches.length) {

		case 1: // one-fingered touch: rotate

			if (scope.noRotate === true) return;

			state = STATE.TOUCH_ROTATE;

			rotateStart.set(event.touches[0].pageX, event.touches[0].pageY);
			break;

		case 2: // two-fingered touch: dolly

			if (scope.noZoom === true) return;

			state = STATE.TOUCH_DOLLY;

			var dx = event.touches[0].pageX - event.touches[1].pageX;
			var dy = event.touches[0].pageY - event.touches[1].pageY;
			var distance = Math.sqrt(dx * dx + dy * dy);
			dollyStart.set(0, distance);
			break;

		case 3: // three-fingered touch: pan

			if (scope.noPan === true) return;

			state = STATE.TOUCH_PAN;

			panStart.set(event.touches[0].pageX, event.touches[0].pageY);
			break;

		default:

			state = STATE.NONE;

		}

		scope.dispatchEvent(startEvent);

	}

	function touchmove(event) {

		if (scope.enabled === false) return;

		event.preventDefault();
		event.stopPropagation();

		var element = scope.domElement === document ? scope.domElement.body : scope.domElement;

		switch (event.touches.length) {

		case 1: // one-fingered touch: rotate

			if (scope.noRotate === true) return;
			if (state !== STATE.TOUCH_ROTATE) return;

			rotateEnd.set(event.touches[0].pageX, event.touches[0].pageY);
			rotateDelta.subVectors(rotateEnd, rotateStart);

			// rotating across whole screen goes 360 degrees around
			scope.rotateLeft(2 * Math.PI * rotateDelta.x / element.clientWidth * scope.rotateSpeed);
			// rotating up and down along whole screen attempts to go 360, but limited to 180
			scope.rotateUp(2 * Math.PI * rotateDelta.y / element.clientHeight * scope.rotateSpeed);

			rotateStart.copy(rotateEnd);

			scope.update();
			break;

		case 2: // two-fingered touch: dolly

			if (scope.noZoom === true) return;
			if (state !== STATE.TOUCH_DOLLY) return;

			var dx = event.touches[0].pageX - event.touches[1].pageX;
			var dy = event.touches[0].pageY - event.touches[1].pageY;
			var distance = Math.sqrt(dx * dx + dy * dy);

			dollyEnd.set(0, distance);
			dollyDelta.subVectors(dollyEnd, dollyStart);

			if (dollyDelta.y > 0) {

				scope.dollyOut();

			} else {

				scope.dollyIn();

			}

			dollyStart.copy(dollyEnd);

			scope.update();
			break;

		case 3: // three-fingered touch: pan

			if (scope.noPan === true) return;
			if (state !== STATE.TOUCH_PAN) return;

			panEnd.set(event.touches[0].pageX, event.touches[0].pageY);
			panDelta.subVectors(panEnd, panStart);

			scope.pan(panDelta.x, panDelta.y);

			panStart.copy(panEnd);

			scope.update();
			break;

		default:

			state = STATE.NONE;

		}

	}

	function touchend( /* event */ ) {

		if (scope.enabled === false) return;

		scope.dispatchEvent(endEvent);
		state = STATE.NONE;

	}

	this.domElement.addEventListener('contextmenu', function (event) {
		event.preventDefault();
	}, false);
	this.domElement.addEventListener('mousedown', onMouseDown, false);
	this.domElement.addEventListener('mousewheel', onMouseWheel, false);
	this.domElement.addEventListener('DOMMouseScroll', onMouseWheel, false); // firefox

	this.domElement.addEventListener('touchstart', touchstart, false);
	this.domElement.addEventListener('touchend', touchend, false);
	this.domElement.addEventListener('touchmove', touchmove, false);

	window.addEventListener('keydown', onKeyDown, false);

	// force an update at start
	this.update();

};

THREE.OrbitControls.prototype = Object.create(THREE.EventDispatcher.prototype);
var Sphere = (function(){

    function Sphere(){
        THREE.Object3D.call(this);

        var geometry = new THREE.SphereGeometry(35);
        var material = new THREE.MeshBasicMaterial({color: 0x3facc8, wireframe: true});
        this.mesh = new THREE.Mesh(geometry, material);
        this.add(this.mesh);
    }

    Sphere.prototype = new THREE.Object3D;
    Sphere.prototype.constructor = Sphere;

    Sphere.prototype.update = function() {
        this.mesh.rotation.y += 0.01;
    };

    return Sphere;
})();
ParticleShader = {

	uniforms: {},

	vertexShader: [

		"void main() {",

		"gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

		"}"

	].join("\n"),

	fragmentShader: [

		"void main() {",

		"gl_FragColor = vec4( 1.0, 0.0, 0.0, 0.5 );",

		"}"

	].join("\n")

};
//# sourceMappingURL=app.min.js.map